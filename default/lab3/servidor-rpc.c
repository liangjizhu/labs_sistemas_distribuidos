/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "tuplas.h"
#include <pthread.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    int key;
    char value1[256];
    int N_value2;
    double V_value2[32];
    Coord value3;
} Tupla;

static Tupla *tuplas = NULL;
static int num_tuplas = 0;
static int capacidad  = 0;
static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;

bool_t
set_value_1_svc(set_args arg1, int *result,  struct svc_req *rqstp)
{
	*result = -1;
    /* Validaciones bÃ¡sicas */
    if (strlen(arg1.value1) > 255 || arg1.N_value2 < 1 || arg1.N_value2 > 32)
        return TRUE;

    pthread_mutex_lock(&mtx);

    /* No permitir claves duplicadas */
    for (int i = 0; i < num_tuplas; i++) {
        if (tuplas[i].key == arg1.key) {
            pthread_mutex_unlock(&mtx);
            return TRUE;
        }
    }

    /* Redimensionar si es necesario */
    if (num_tuplas == capacidad) {
        int nueva = capacidad == 0 ? 16 : capacidad * 2;
        Tupla *tmp = realloc(tuplas, nueva * sizeof(Tupla));
        if (!tmp) {
            pthread_mutex_unlock(&mtx);
            return TRUE;
        }
        tuplas = tmp;
        capacidad = nueva;
    }

    /* Insertar */
    Tupla *t = &tuplas[num_tuplas++];
    t->key        = arg1.key;
    strncpy(t->value1, arg1.value1, 255);
    t->value1[255]= '\0';
    t->N_value2   = arg1.N_value2;
    memcpy(t->V_value2,
           arg1.V_value2.V_value2_val,
           sizeof(double) * arg1.N_value2);
    t->value3     = arg1.value3;

    *result = 0;
    pthread_mutex_unlock(&mtx);
    return TRUE;
}

bool_t
get_value_1_svc(int arg1, get_result *result,  struct svc_req *rqstp)
{
	// arg1 = key
	result->status = -1;
    pthread_mutex_lock(&mtx);
    for (int i = 0; i < num_tuplas; i++) {
        if (tuplas[i].key == arg1) {
            Tupla *t = &tuplas[i];
            result->status = 0;

            /* Cadena: rpcgen la libera con xdr_free */
            result->value1 = strdup(t->value1);

            /* Vector */
            result->N_value2 = t->N_value2;
            result->V_value2.V_value2_len = t->N_value2;
            result->V_value2.V_value2_val = malloc(sizeof(double) * t->N_value2);
            memcpy(result->V_value2.V_value2_val,
                   t->V_value2,
                   sizeof(double) * t->N_value2);

            /* Coord */
            result->value3 = t->value3;

            break;
        }
    }
    pthread_mutex_unlock(&mtx);
    return TRUE;
}

bool_t
modify_value_1_svc(modify_args arg1, int *result,  struct svc_req *rqstp)
{
	*result = -1;
    if (strlen(arg1.value1) > 255 || arg1.N_value2 < 1 || arg1.N_value2 > 32)
        return TRUE;

    pthread_mutex_lock(&mtx);
    for (int i = 0; i < num_tuplas; i++) {
        if (tuplas[i].key == arg1.key) {
            Tupla *t = &tuplas[i];
            strncpy(t->value1, arg1.value1, 255);
            t->value1[255] = '\0';
            t->N_value2 = arg1.N_value2;
            memcpy(t->V_value2,
                   arg1.V_value2.V_value2_val,
                   sizeof(double) * arg1.N_value2);
            t->value3 = arg1.value3;
            *result = 0;
            break;
        }
    }
    pthread_mutex_unlock(&mtx);
    return TRUE;
}

bool_t
delete_key_1_svc(int arg1, int *result,  struct svc_req *rqstp)
{
	
	*result = -1;
    pthread_mutex_lock(&mtx);
    for (int i = 0; i < num_tuplas; i++) {
        if (tuplas[i].key == arg1) {
            /* desplazar */
            for (int j = i; j + 1 < num_tuplas; j++)
                tuplas[j] = tuplas[j+1];
            num_tuplas--;
            *result = 0;
            break;
        }
    }
    pthread_mutex_unlock(&mtx);
    return TRUE;
}

bool_t
exist_1_svc(int arg1, int *result,  struct svc_req *rqstp)
{
	*result = -1;
    pthread_mutex_lock(&mtx);
    for (int i = 0; i < num_tuplas; i++) {
        if (tuplas[i].key == arg1) {
            *result = 1;
            pthread_mutex_unlock(&mtx);
            return TRUE;
        }
    }
    *result = 0;
    pthread_mutex_unlock(&mtx);
    return TRUE;
}

bool_t
destroy_1_svc(int *result, struct svc_req *rqstp)
{
	pthread_mutex_lock(&mtx);
    free(tuplas);
    tuplas     = NULL;
    num_tuplas = 0;
    capacidad  = 0;
    pthread_mutex_unlock(&mtx);
    *result = 0;
    return TRUE;
}

int
tuplas_prog_1_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free(xdr_result, result);
    return 1;
}
